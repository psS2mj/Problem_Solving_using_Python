# DFS 구현: 스택 + 반복문
# 스택은 함수의 재귀호출이 쌓이는 곳.
# 즉, 재귀는 스택과 같은 구조다.
# 따라서 DFS는 스택으로 구현할 수도 있고, 재귀로 구현할 수도 있다.
# (👨🏻‍🏫스택은 뭐..하는데 시간이 좀 걸려서 반복문이 속도는 더 빠르다는 듯?!)

# BFS 구현: 큐 + 반복문으로만 구현 가능.

arr = [
[0,0,0,0,0,0,0],
[0,0,1,1,1,0,0],
[0,0,0,0,1,0,0],
[0,0,1,1,1,1,1],
[0,0,1,0,1,0,0],
[0,0,1,1,1,0,0],
[0,0,0,1,0,0,0]
]
N = 7
# DFS: 연결된 것은 몇 개?!
# 👨🏻‍🏫DFS: 갈 수 있는 경로를 보면 바로 진입, 갈 수 있는 길이 없으면 되돌아간다.

start_r = 1
start_c = 2

# 상하좌우(4방)로 연결된 1의 개수를 세기 위한 dfs (시작점은 무조건 1 => result는 1부터 시작한다.)
def dfs(r,c): # (r,c)는 시작점이 된다.
    stack = list()
    stack.append((r,c))
    result = 1 # result: 연결된 1의 개수 (1부터 시작)
    # 왔던 길을 되돌아가지 않기 위한 배열 (방문했다는 것 표시하기)
    visited = [[0]*7 for _ in range(7)] # 7*7 배열
    visited[r][c] = 1 # 시작좌표는 이미 방문한 상태로 시작한다.
    # 상하좌우
    dr = [-1,1,0,0]
    dc = [0,0,-1,1]
    # 해당 좌표에서 더이상 갈 수 있는 길이 없으면 stack에서 뺀다.
    # 👨🏻‍🏫갈 수 있는 길이 있다면 stack에 계속해서 좌표가 추가될 것이고, 없으면 stack이 비어 있을 것이다.
    while stack: # 스택에 요소가 있으면 계속해서 길찾기 시도! (👨🏻‍🏫스택이 비어있지 않으면 True)
        # 현재 위치(좌표, 스택에서 가장 위(top)에 있는 좌표)에서 갈 수 있는 길찾기를 반복한다.
        top_r,top_c = stack[-1] # 👨🏻‍🏫unpacking 되면서 r과 c로 갈라져서 들어간다.
        is_find = False
        for d in range(4): # 내가 갈 수 있는 경로가 있는지 찾는 for문
            nr = top_r + dr[d]
            nc = top_c + dc[d]
            # 1. nr,nc가 배열의 범위를 벗어나지 않는지 체크한다. (👨🏻‍🏫유효한 좌표인가?)
            # 2. 해당 좌표에 1이 있는지 확인 (arr 배열)
            # 3. 아직 방문하지 않은 좌표인지 확인 (visited 배열)
            # 1,2,3에서 모두 걸리지 않으면 이동한다.
            if 0 <= nr < N and 0 <= nc < N and arr[nr][nc] == 1 and visited[nr][nc] == 0:
                stack.append((nr,nc)) # 스택에 경로 추가
                result += 1 # 갈 수 있는 길을 하나 더 찾은 것! (연결된 개수 증가)
                visited[nr][nc] = 1 # 방문표시
                is_find = True # 길 찾음
                break # 갈 수 있는 경로를 찾았기 때문에 더이상 경로를 찾지 않아도 된다. (nr,nc는 현재 stack의 top에 있다: 현재 위치)
        if not is_find: # 한 번도 위의 if문에 안 걸렸다면 되돌아간다. (👨🏻‍🏫경로를 못 찾은 경우!)
            # 경로를 못 찾았으니 여태 저장한 경로에서 좌표를 빼면 된다.
            stack.pop()

    return result

result = dfs(start_r,start_c)
print(result) # 결과: 15