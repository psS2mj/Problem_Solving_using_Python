# 👨🏻‍🏫가장 비싼 날에 팔면 된다.
# 가장 비싼 날보다 앞에 있는 날에 다 산다. (뒤에 있는 날에 살 수는 없으니..)

# 1. 물건값이 최대인 날을 찾음 (최대값 찾기)
# 2. 물건값이 최대인 날보다 이전인 경우, 물건을 산다.
#    (최대 물건값 - 현재 물건값 : 내 이익에 더함)
# 3. 물건값이 최대인 날 물건을 판다. (아무 작업 안 함)
# 4. 물건을 판 이후, 1~3을 반복 (1~3 반복)
# 5. 예측 가능한 마지막 날이면 종료

# 👨🏻‍🏫강사님 풀이
T = int(input())
for tc in range(1,T+1):
    N = int(input())
    costs = list(map(int,input().split()))
    result = 0
    # 최대값 위치 까지 도달하면, (1,2 를 반복한다)
    # 반복의 횟수를 알 때(특정횟수, 배열의 길이 만큼, 주어진 값 만큼) : for,
    # 횟수를 모를 때(조건) : while
    idx = 0
    while idx < N:
        # 1 2 3 5 1 2 3 4
        # 1. costs에서 최대값을 찾는다.
        max_i = idx
        max_v = costs[max_i]
        for i in range(idx,len(costs)):
            if costs[i] >= max_v:
                max_v = costs[i]
                max_i = i
        # 반복문을 다돌면 최대값의 인덱스를 찾음
        # 2. 최대값 이전 위치까지 수익을 더해간다.
        for i in range(idx,max_i):
            result += (max_v - costs[i])
        idx = max_i + 1 # 최대값 다음부터 비교해야 한다
    print("#{} {}".format(tc,result))

# 👨🏻‍🏫이 문제를 더 쉽게 푸는 방법은 뒤에서부터 푸는 것.
# 맨 뒤의 숫자를 최대값으로 잡고, 내 앞의 숫자가 나보다 작으면 이익을 더해준다.
# 만약 나보다 더 큰 숫자가 나오면 멈추고 최대값을 업데이트 해준다.
# 위 작업을 반복한다. => 한 번의 반복문으로 해결 가능!!